#!/usr/bin/env ruby
#
# Puavo Devices Client
# * simple command-line script for registering devices
#   to the Puavo Devices Server
#
# TODO
# * localization by user settings and by operating system default locale?
# * how to ask device information that is not required
#   (latitude, longitude, description etc.)?

# suggestion: run this as:
#   script -qc ./puavo-client-register /root/register.log

require 'facter'
require 'getoptlong'
require 'highline/import'
require 'json'
require 'net/http'
require 'resolv'
require 'uri'

# XXX should be obtained from server?
FIELD_ORDER = %w(
  school
  devicetype
  puavoHostname
  serialNumber
  puavoDeviceManufacturer
  puavoDeviceModel
  macAddress
  puavoDevicePrimaryUser
  tags
)

class PuavoDevicesClient
  # XXX should be obtained from server?
  FIELD_TRANSLATIONS = {
    'en' => {
       'devicetype'              => 'Devicetype',
       'macAddress'              => 'MAC address(es)',
       'puavoDeviceManufacturer' => 'Manufacturer',
       'puavoDeviceModel'        => 'Model name',
       'puavoDevicePrimaryUser'  => 'Primary user',
       'puavoHostname'           => 'Hostname',
       'school'                  => 'School',
       'serialNumber'            => 'Serial number',
       'tags'                    => 'Tags',
    }
  }

  def initialize(params, host_defaults)
    facts = Facter.to_hash

    @batch_mode  = params['batch']
    @puavoserver = params['puavoserver'] || lookup_default_puavoserver()
    @username    = params['username']
    @password    = params['password']

    # defaults (mostly) from facter
    @host = {
      'macAddress'              => lookup_macaddresses(facts),
      'puavoDeviceManufacturer' => facts['manufacturer'],
      'puavoDeviceModel'        => facts['productname'],
      'puavoHostname'           => facts['hostname'],
      'serialNumber'            => facts['serialnumber'],
    }

    # let host defaults (from command line) override host values
    @host.merge!(host_defaults)
  end

  def ask_devicetype()
    @host['devicetype'] = choicelist(@devicetypes,
				     'devicetype',
				     'Device type selection',
				     'Select device type: ')
  end

  def ask_machine_info(errors={}, ask_all=true)
    unhandled = errors.clone
    FIELD_ORDER.each do |field|
      next unless ask_all or unhandled[field]
      if unhandled[field] and not ask_all
	errmsg(unhandled[field])
	unhandled.delete(field)
      end

      case field
	when 'devicetype'
	  ask_devicetype()
	when 'school'
	  ask_school()
	else
	  question = FIELD_TRANSLATIONS['en'][field] + ':'
          @host[field] = ask_with_default(question, @host[field])
      end
    end
    unhandled.each do |field, errmsg|
      errmsg("Server reported unhandled error for #{ field }: #{ errmsg }")
    end
  end

  def ask_school()
    @host['school'] \
      = @schools.size == 1 ? @schools[0]['id'] \
      : choicelist(@schools,
		   'school',
     		   'School selection',
     		   'Select school: ')
  end

  def ask_with_default(question, default)
    answer = HighLine.ask("#{ question } [#{ default }] ") do |q|
							     q.whitespace = nil
							   end
    return answer.match(/^\n$/)  ? default \
	 : answer.match(/^\s+$/) ? ''      \
	 : answer.strip
  end

  def choicelist(items, hostfield, header, prompt)
    selected = nil
    choose do |menu|
      items.each do |item|
	menu.choice(item['label']) { selected = item['id'] }
        menu.layout = :list
      end
      if @host.has_key?(hostfield)
        menu.prompt =
	  prompt + "[#{ find_label_for_id(@host[hostfield], items) }] "
	menu.hidden('') { selected = @host[hostfield] }
      else
	menu.prompt = prompt
      end
      menu.header = header
    end
    HighLine.say "===> selected [#{ find_label_for_id(selected, items) }]"
    selected
  end

  def connect_to_puavo(server)
    @http = Net::HTTP.new(server, '80')
    @devicetypes = get('/devices/hosts/types.json')
    userinfo     = get('/devices/sessions/show.json')
    @schools     = userinfo['managed_schools'].map do |school|
		     {
		       'id'    => school['puavoId'].to_s,
		       'label' => school['displayName'],
		     }
		   end
  end

  def connect_to_puavo_with_questions()
    until (@http and @username and @password)
      begin
	begin
	  @puavoserver = ask_with_default('Puavo server name:', @puavoserver)
	  connect_to_puavo(@puavoserver)
	rescue HttpAuthError
	end
	@username    = ask_with_default('Username:', @username)
	@password    = HighLine.ask('Password: ') { |q| q.echo = '*' }
	connect_to_puavo(@puavoserver)
      rescue HttpAuthError
	errmsg('Wrong username and/or password')
	@http = nil
      rescue SocketError => e
	errmsg(e)
	@http = nil
      end
    end
  end

  def errmsg(msg)
    HighLine.say(HighLine.new.color("*** ERROR: #{ msg }", HighLine::RED))
  end

  def find_label_for_id(id, items)
    itemhash = Hash[ items.map { |i| [ i['id'], i['label'] ] } ]
    itemhash[id]
  end

  def get(url, params = {})
    @http.start do |http|
      http_header = @cookie ? { "Cookie" => @cookie } : nil
      unless params.empty?
        url += '?'
        params.each do |key, value|
          case value.class.to_s
	    when 'Array'
	      url += value.map { |v| "#{ key }[]=#{ v }" }.join('&')
	    else
	      url += "#{ key }=#{ value }"
	    end
        end
      end

      request = Net::HTTP::Get.new(url, http_header)
      request.basic_auth(@username, @password)
      response = http.request(request)
      if response.class == Net::HTTPUnauthorized
	raise HttpAuthError
      end
      @cookie = response['Set-Cookie']
      JSON.parse(response.body)
    end
  end

  def lookup_default_puavoserver
    Resolv::DNS.open do |dns|
      r = dns.getresources('_puavo._tcp.opinsys.fi',
			   Resolv::DNS::Resource::IN::SRV)
      r[0].target.to_s
    end
  end

  def lookup_macaddresses(facts)
    facts['interfaces'].split(',').
			map { |intf| facts["macaddress_#{intf}"] }.
			sort.uniq.join(' ')
  end

  def print_machine_info
    HighLine.say "\nHOST INFORMATION:"
    FIELD_ORDER.each do |field|
      value =
	case field
	  when 'devicetype'
	    find_label_for_id(@host[field], @devicetypes)
	  when 'school'
	    find_label_for_id(@host[field], @schools)
	  else
	    @host[field]
	end
      printf("%-20s%s\n", FIELD_TRANSLATIONS['en'][field] + ': ', value)
    end
    print "\n"
  end

  def post(url, object_form)
    http_header = @cookie ? { "Cookie" => @cookie } : nil
    request = Net::HTTP::Post.new(url, http_header)

    params = object_form['attributes'].merge('authenticity_token' => object_form['authenticity_token'])
    request.set_form_data(params)
    response = @http.request(request)
    @cookie = response['Set-Cookie']
    response_code = response.code
    case response_code
      when /^2/
	# successful request
        Hash[ 'errors' => {}, 'info' => JSON.parse(response.body), ]
      when /^5/
        # FIXME: Error handling when response is HTTPServerError
        {}
      else
	Hash[
	  'errors' => Hash[ JSON.parse(response.body) ]
	]
    end
  end

  def register_to_server()
    if (@puavoserver and @username and @password)
      connect_to_puavo(@puavoserver)
    else
      connect_to_puavo_with_questions()
    end

    ask_school() unless @host['school']
    unless @schools.map { |s| s['id'] }.include?(@host['school'])
      errmsg("School ID is set to '#{ @host['school'] }'" +
	     ' but user cannot manage such a school')
      ask_school()
    end

    ask_devicetype() unless @host['devicetype']
    unless @devicetypes.map { |d| d['id'] }.include?(@host['devicetype'])
      errmsg("Device type ID is set to '#{ @host['devicetype'] }'" +
	     ' but user cannot add such a device type')
      ask_devicetype()
    end

    loop do
      print_machine_info()
      until @batch_mode or agree('Is this information correct? (y/n) ')
	ask_machine_info()
	print_machine_info()
      end

      # puavoLocalbootDevice should not be hardcoded
      device_form = get("/devices/#{ @host['school' ]}/devices/new.json",
			'device[classes]' => %w(puavoLocalbootDevice))
      set_form_attribute_values(device_form)
      HighLine.say 'Sending machine information to puavo server...'
      register_info = post("/devices/#{ @host['school'] }/devices.json",
			   device_form)
      if register_info['errors'].empty?
        return register_info
      else
	ask_machine_info(register_info['errors'], false)
      end
    end
  end

  def set_form_attribute_values(object_form)
    object_form['attributes'].each do |field, value|
      attribute = field.match(/\[(.*)\]$/)[1]
      if @host.has_key?(attribute)
        object_form['attributes'][field] = @host[attribute]
      end
    end
  end
end

class HttpAuthError < Exception; end

def cmdline_params()
  params =
    FIELD_ORDER.map { |f| [ "--#{ f }", GetoptLong::OPTIONAL_ARGUMENT ] } \
    + [
        [ '--batch',       GetoptLong::NO_ARGUMENT       ],
        [ '--puavoserver', GetoptLong::OPTIONAL_ARGUMENT ],
        [ '--username',    GetoptLong::OPTIONAL_ARGUMENT ],
        [ '--password',    GetoptLong::OPTIONAL_ARGUMENT ],
      ]

  opts = GetoptLong.new(*params)
  host_params, other_params = {}, {}
  opts.each do |opt, arg|
    stripped_opt = opt.match(/^--(.*)$/)[1]
    if FIELD_ORDER.include?(stripped_opt)
      host_params[stripped_opt] = arg
    else
      other_params[stripped_opt] = arg
    end
  end
  {
    'host'  => host_params,
    'other' => other_params,
  }
end

#
# MAIN
#

HighLine.say "\n\t-=< Puavo Devices Client >=-\n\n"

cmdline_params = cmdline_params()
puavoclient    = PuavoDevicesClient.new(cmdline_params['other'],
					cmdline_params['host'])
register_info  = puavoclient.register_to_server()

HighLine.say 'This machine has been successfully registered.'
